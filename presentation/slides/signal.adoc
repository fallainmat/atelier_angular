== Signal

[NOTE.speaker]
****
Signal est arrivé avec Angular 16 suite à la RFC https://github.com/angular/angular/discussions/49685.
****


=== Detection de changement avant Signal

=== !

Zone.js planifie la détection de changement.

[NOTE.speaker]
--
* Détection de changement avec un exemple simple.
* Aborder le concept de zone et de propagation.
--

=== !

image::images/signal/event.png[]

[NOTE.speaker]
--
* Exemple simple d'un événement déclencher sur le composant child2.
* Il n'y a qu'un seul impact sur le composant subChild2.
--

=== !

image::images/signal/zone.png[]

=== Detection de changement avec Signal

[NOTE.speaker]
--
* Le principe de propagation est explicite dans le visuel.
* La propagation est propagé sur tous les enfants.
--

=== !

Un signal est modifié, il va émettre qu'auprès des composants qui consomment ce signal.

=== !

image::images/signal/event.png[]

=== !

image::images/signal/signal.png[]

=== C'est quoi un signal ?

=== !

Deux Types de Signaux

* Writable
* Read-only

[%auto-animate]
=== Signal Writable

[%auto-animate]
=== Signal Writable

* Signal

=== !

[source,typescript, highlight="7"]
----
@Component({
  selector: 'app-root',
  standalone: true,
  templateUrl: './app.component.html',
})
export class AppComponent {
  count: WritableSignal<number> = signal(0);
}
----

=== !

[source,html,linenums]
----
<p>{{count()}}</p>
----

[%auto-animate]
=== Signaux Read-only

[%auto-animate]
=== Signaux Read-only

* Computed
* Effect

[%auto-animate]
=== Computed

=== !

[source,typescript,linenums, data-id=computed, highlight="8|9..10"]
----
...
@Component({
  selector: 'app-root',
  standalone: true,
  templateUrl: './app.component.html',
})
export class AppComponent {
  count: WritableSignal<number> = signal(0);
  doubleCount: Signal<number> = computed(() =>
        this.count() * 2);
}
----

[NOTE.speaker]
--
* Le computed est un signal qui dépend d'un autre signal.
--

=== !

[source,html,linenums]
----
<p>{{doubleCount()}}</p>
----

[%auto-animate]
=== Effect

[%auto-animate]
=== !

[source,typescript, highlight="7|11|10..12"]
----
@Component({
  selector: 'app-root',
  standalone: true,
  templateUrl: './app.component.html',
})
export class AppComponent {
  count: WritableSignal<number> = signal(0);

  constructor() {
    effect(() => {
      console.log(this.count());
    });
  }
}
----

[NOTE.speaker]
--
* L'ensemble de l'effect est exécuté à chaque fois que le signal count est modifié.
--

=== !

image::images/common/demo.png[]

=== Preview TIME

image::images/signal/slalom.gif[]

=== Signal Input

Nouvelle façon d'utiliser l'input dans un composant enfant. input()

[%auto-animate]
=== Signal Input

Pourquoi utiliser input() au lieu du décorateur @Input() ?

[%auto-animate]
=== Signal Model

Nouvelle façon d'utiliser l'input/output dans un seul "signal". plus besoin de faire un set/update pour changer la valeur.

[%auto-animate]
=== Signal Queries

On dénombre 2 types de Query :

- View Queries.
- Content Queries.

[%auto-animate]
=== Signal Queries

View remplace ViewChild et Content remplace ContentChild.

[%auto-animate]
=== HttpClient

[%auto-animate]
=== HttpClient

Pourquoi je vous parle d'HttpClient ?

HttpClient fonctionne toujours avec les observables

[%auto-animate]
=== HttpClient

* toSignal()
* toObservable()

[%auto-animate]
=== !
[source,typescript,linenums,data-id=component, highlight="2|4..6"]
----
export class TestService {
  httpClient = inject(HttpClient);

  get(date: string): Observable<Interface> {
    return this.httpClient.get<Interface>(`url`);
  }
}
----

=== !
[source,typescript,linenums,data-id=component, highlight="5|1..2,7|1..2,9"]
----
import {toSignal, toObservable} from
"@angular/core/rxjs-interop";

export class TestComponent {
    $test: Observable<number> = of(1)

    test: Signal<number> = toSignal(this.$test);

    $test2: Observable<number> = toObservable(this.test);
}
----
